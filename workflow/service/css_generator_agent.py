"""
CSS generator agent for creating multiple color theme variations.

Provides functionality for generating new CSS color themes based on existing
CSS files and theme information using OpenAI LLM integration.
"""

import argparse
import json
import os
import sys
from pathlib import Path
from typing import List, Dict, Any
from concurrent.futures import ThreadPoolExecutor, as_completed

from openai import OpenAI
from pydantic import BaseModel, Field

from common.config.config import get_workflow_config
from common.utils.logger import get_logger


logger = get_logger(__name__)

# Prompts for OpenAI CSS theme generation (single-theme concurrent mode)
SINGLE_THEME_GENERATION_PROMPT = """
You are a CSS theme design expert. Generate ONE new color theme variation based on an original CSS file and existing theme information.

Objectives:
1) Analyze the original CSS to understand structure and color usage
2) Use ONLY color changes (hex/rgb/rgba/hsl/hsla/named/CSS variables); preserve all other properties unchanged
3) Create ONE completely new and distinct color theme with a unique color scheme
4) Return the complete modified CSS and a JSON description with title and representative_colors

CRITICAL: Uniqueness Requirements:
- Carefully analyze representative colors from ALL existing themes provided
- Ensure this theme uses a COMPLETELY DIFFERENT color palette from existing themes
- Avoid similar combinations, hues, saturation levels, and brightness already present
- Follow the provided diversity directive strictly to further reduce overlap with other concurrently generated themes

Filename requirements:
- Generate a unique, descriptive, lowercase filename with underscores
- Must not conflict with any existing filenames provided
- The same filename will be used for both CSS and JSON files (different extensions)

JSON description requirements:
- Provide a descriptive title capturing the unique color theme
- Extract 3-6 representative HEX colors from the generated CSS

Return JSON with:
- filename: string
- css_content: string (complete CSS with only color changes)
- theme_description: object with fields: title (string), representative_colors (array of strings)
"""

# Fixed diversity directives to guide concurrent jobs toward different palettes
DIVERSITY_DIRECTIVES: List[str] = [
    "Warm complementary palette focusing on reds/oranges with contrasting teals",
    "Cool analogous palette focusing on blues/cyans with subtle purples",
    "High-contrast monochrome with accent highlights (dark base, neon accents)",
    "Muted earthy palette with desaturated greens/browns and soft neutrals",
    "Vibrant triadic palette (distinct primaries split across UI areas)",
]


class CssFileReadError(Exception):
    """Exception raised when CSS file reading fails."""
    
    def __init__(self, css_file_path: str, error_message: str):
        self.css_file_path = css_file_path
        self.error_message = error_message
        super().__init__(f"Failed to read CSS file {css_file_path}: {error_message}")


class ThemesDirectoryError(Exception):
    """Exception raised when themes directory operations fail."""
    
    def __init__(self, themes_directory: str, error_message: str):
        self.themes_directory = themes_directory
        self.error_message = error_message
        super().__init__(f"Themes directory error in {themes_directory}: {error_message}")


class ThemeGenerationError(Exception):
    """Exception raised when theme generation fails."""
    
    def __init__(self, error_message: str):
        self.error_message = error_message
        super().__init__(f"Theme generation failed: {error_message}")


class ExistingThemeInfo(BaseModel):
    """
    Pydantic model for existing theme information.
    
    This model represents information about existing themes
    found in the themes directory.
    """
    
    filename: str = Field(
        ...,
        description="The filename of the existing theme JSON file (without extension)"
    )
    content: Dict[str, Any] = Field(
        ...,
        description="The JSON content of the existing theme file"
    )

    model_config = {
        "validate_assignment": True,
        "extra": "forbid"
    }


class GeneratedTheme(BaseModel):
    """
    Pydantic model for generated theme results from OpenAI.
    
    This model defines the structure of each theme generated by OpenAI
    for new color theme variations.
    """
    
    filename: str = Field(
        ...,
        description="Unique filename for the theme (without extension, used for both CSS and JSON)"
    )
    css_content: str = Field(
        ...,
        description="Complete CSS content with modified colors but preserved structure"
    )
    theme_description: Dict[str, Any] = Field(
        ...,
        description="JSON description containing title and representative_colors"
    )

    model_config = {
        "validate_assignment": True,
        "extra": "forbid"
    }


class ThemeGenerationResult(BaseModel):
    """
    Pydantic model for the complete theme generation response from OpenAI.
    
    This model defines the structure of the JSON response containing
    all 5 generated theme variations.
    """
    
    generated_themes: List[GeneratedTheme] = Field(
        ...,
        description="List of 5 generated theme variations"
    )

    model_config = {
        "validate_assignment": True,
        "extra": "forbid"
    }


class CssGeneratorResult(BaseModel):
    """
    Result of the concurrent CSS theme generation agent execution.
    """

    generated_count: int = Field(..., description="Number of generated theme variations")
    themes_directory_path: str = Field(..., description="Path where themes are written")
    success: bool = Field(..., description="Whether generation completed successfully")
    message: str = Field(..., description="Summary message for the operation")



def _scan_existing_themes(themes_directory_path: str) -> List[ExistingThemeInfo]:
    """
    Scan the themes directory for existing JSON theme files.
    
    Args:
        themes_directory_path: Path to the themes directory
        
    Returns:
        List of ExistingThemeInfo containing filename and content of each theme
        
    Raises:
        ThemesDirectoryError: If directory scanning fails
    """
    logger.info(f"Scanning themes directory for existing JSON files: {themes_directory_path}")
    
    themes_dir = Path(themes_directory_path)
    existing_themes = []
    
    if not themes_dir.exists():
        logger.warning(f"Themes directory does not exist: {themes_directory_path}")
        return existing_themes
    
    try:
        # Find all JSON files in themes directory
        for json_file in themes_dir.glob("*.json"):
            try:
                # Read JSON content
                with open(json_file, 'r', encoding='utf-8') as file:
                    json_content = json.load(file)
                
                # Get filename without extension
                filename = json_file.stem
                
                existing_themes.append(ExistingThemeInfo(
                    filename=filename,
                    content=json_content
                ))
                logger.info(f"Found existing theme: {filename}")
                
            except Exception as e:
                logger.warning(f"Failed to read JSON file {json_file}: {e}")
                continue
        
        logger.info(f"Found {len(existing_themes)} existing theme files")
        return existing_themes
        
    except Exception as e:
        logger.error(f"Error scanning themes directory: {e}")
        raise ThemesDirectoryError(themes_directory_path, str(e))


def _generate_single_theme(
    original_css_content: str,
    existing_themes: List[ExistingThemeInfo],
    diversity_directive: str,
) -> GeneratedTheme:
    """
    Generate a single new theme variation using OpenAI, guided by a diversity directive.

    Args:
        original_css_content: Content of the original CSS file
        existing_themes: List of existing themes to avoid conflicts
        diversity_directive: Specific guidance to push palette diversity

    Returns:
        GeneratedTheme: The newly generated theme

    Raises:
        ThemeGenerationError: If theme generation fails
    """
    logger.info("Generating single theme variation using OpenAI")

    try:
        workflow_config = get_workflow_config()
        client = OpenAI(api_key=workflow_config.openai_api_key)

        json_schema = {
            "type": "object",
            "properties": {
                "filename": {
                    "type": "string",
                    "description": "Unique filename for the theme (without extension)"
                },
                "css_content": {
                    "type": "string",
                    "description": "Complete CSS content with modified colors"
                },
                "theme_description": {
                    "type": "object",
                    "properties": {
                        "title": {
                            "type": "string",
                            "description": "Descriptive title for the theme"
                        },
                        "representative_colors": {
                            "type": "array",
                            "items": {"type": "string"},
                            "description": "List of representative colors in HEX format"
                        }
                    },
                    "required": ["title", "representative_colors"],
                    "additionalProperties": False
                }
            },
            "required": ["filename", "css_content", "theme_description"],
            "additionalProperties": False
        }

        # Prepare existing themes info
        existing_filenames = [theme.filename for theme in existing_themes]
        existing_themes_info = ""
        if existing_themes:
            existing_themes_info = "Existing Theme Files (avoid these filenames and color combinations):\n\n"
            for theme in existing_themes:
                title = theme.content.get("title", "Unknown")
                colors = theme.content.get("representative_colors", [])
                existing_themes_info += f"Theme: {theme.filename}\n"
                existing_themes_info += f"  Title: {title}\n"
                existing_themes_info += (
                    f"  Representative Colors: {', '.join(colors) if colors else 'None specified'}\n\n"
                )
            existing_themes_info += (
                "CRITICAL: Analyze the above color palettes and ensure your new theme uses a COMPLETELY DIFFERENT color scheme. Avoid similar hues, saturation levels, brightness, and color families.\n"
            )
        else:
            existing_themes_info = (
                "No existing theme files found. You have complete creative freedom for color selection.\n"
            )

        input_content = f"""{SINGLE_THEME_GENERATION_PROMPT}

{existing_themes_info}

Diversity Directive (strictly follow):
{diversity_directive}

Existing Filenames (avoid conflicts):
{', '.join(existing_filenames) if existing_filenames else 'None'}

Original CSS Content:
{original_css_content}

Please generate ONE distinct theme based on the directive above. Ensure strong palette uniqueness and filename uniqueness."""

        logger.info("Sending single theme generation request to OpenAI GPT-5 model")

        response = client.responses.create(
            model="gpt-5",
            input=[
                {
                    "role": "user",
                    "content": [
                        {
                            "type": "input_text",
                            "text": input_content
                        }
                    ]
                }
            ],
            text={
                "format": {
                    "type": "json_schema",
                    "name": "single_theme_generation",
                    "strict": True,
                    "schema": json_schema
                },
                "verbosity": "medium"
            },
            reasoning={"effort": "minimal"},
            tools=[],
            store=True,
        )

        logger.info("Received response from OpenAI for single theme generation")

        content = getattr(response, "output_text", None)
        if not content:
            try:
                content_parts = []
                for item in getattr(response, "output", []) or []:
                    for block in getattr(item, "content", []) or []:
                        block_type = getattr(block, "type", "")
                        if block_type in ("output_text", "text") and hasattr(block, "text"):
                            content_parts.append(block.text)
                content = "\n".join(content_parts) if content_parts else ""
            except Exception:
                logger.error(f"Failed to parse response structure: {response}")
                raise ThemeGenerationError(f"Unable to extract content from response: {type(response)}")

        if not content:
            raise ThemeGenerationError("Empty response content from OpenAI")

        logger.info(f"Extracted response content: {content[:200]}...")

        try:
            theme_data = json.loads(content)
        except json.JSONDecodeError as e:
            logger.error(f"Failed to parse JSON response: {content}")
            raise ThemeGenerationError(f"Invalid JSON response from OpenAI: {e}")

        result = GeneratedTheme(**theme_data)
        logger.info(f"Successfully generated theme: {result.filename} - {result.theme_description.get('title', 'Unknown')}")
        return result

    except Exception as e:
        logger.error(f"Error during single theme generation: {e}")
        raise ThemeGenerationError(str(e))


def _generate_new_themes(
    original_css_content: str,
    existing_themes: List[ExistingThemeInfo]
) -> List[GeneratedTheme]:
    """
    Generate 5 new theme variations concurrently using OpenAI, with diversity directives.

    Args:
        original_css_content: Content of the original CSS file
        existing_themes: List of existing themes to avoid conflicts

    Returns:
        List of GeneratedTheme objects with new theme variations

    Raises:
        ThemeGenerationError: If any theme generation fails
    """
    logger.info("Generating 5 new theme variations concurrently using OpenAI")

    futures = []
    results: List[GeneratedTheme] = []
    errors: List[str] = []

    with ThreadPoolExecutor(max_workers=5) as executor:
        for directive in DIVERSITY_DIRECTIVES:
            futures.append(
                executor.submit(
                    _generate_single_theme,
                    original_css_content,
                    existing_themes,
                    directive,
                )
            )

        for future in as_completed(futures):
            try:
                results.append(future.result())
            except Exception as e:
                errors.append(str(e))

    if errors:
        raise ThemeGenerationError("; ".join(errors))

    # De-duplicate filenames if collisions occur across concurrent generations
    seen: Dict[str, int] = {}
    for theme in results:
        base = theme.filename
        if base not in seen:
            seen[base] = 0
            continue
        seen[base] += 1
        theme.filename = f"{base}_{seen[base]}"

    logger.info(f"Successfully generated {len(results)} theme variations concurrently")
    return results


def _write_theme_files(
    themes_directory_path: str,
    generated_themes: List[GeneratedTheme]
) -> None:
    """
    Write generated theme files to the themes directory.
    
    Args:
        themes_directory_path: Path to the themes directory
        generated_themes: List of generated themes to write
        
    Raises:
        ThemesDirectoryError: If file writing fails
    """
    logger.info(f"Writing {len(generated_themes)} theme files to: {themes_directory_path}")
    
    themes_dir = Path(themes_directory_path)
    
    try:
        # Ensure themes directory exists
        themes_dir.mkdir(parents=True, exist_ok=True)
        
        for theme in generated_themes:
            # Write CSS file
            css_file_path = themes_dir / f"{theme.filename}.css"
            with open(css_file_path, 'w', encoding='utf-8') as file:
                file.write(theme.css_content)
            logger.info(f"Wrote CSS file: {css_file_path}")
            
            # Write JSON file
            json_file_path = themes_dir / f"{theme.filename}.json"
            with open(json_file_path, 'w', encoding='utf-8') as file:
                json.dump(theme.theme_description, file, indent=2, ensure_ascii=False)
            logger.info(f"Wrote JSON file: {json_file_path}")
        
        logger.info("Successfully wrote all theme files")
        
    except Exception as e:
        logger.error(f"Error writing theme files: {e}")
        raise ThemesDirectoryError(themes_directory_path, f"File writing failed: {e}")


def css_generator_agent(
    themes_directory_path: str,
    original_css_file_path: str
) -> CssGeneratorResult:
    """
    Generate multiple color theme variations based on an original CSS file.
    
    This function scans the themes directory for existing themes, reads the original CSS file,
    and uses OpenAI's GPT-5 model to concurrently generate 5 new color theme variations
    (5 parallel requests, one theme per request). Each variation includes both a modified CSS
    file and a corresponding JSON description. The process enforces palette diversity via
    fixed, distinct diversity directives to reduce similarity.
    
    Args:
        themes_directory_path: Path to the themes directory where JSON and CSS files are stored
        original_css_file_path: Path to the original CSS file to base variations on
        
    Raises:
        CssFileReadError: If the original CSS file cannot be read
        ThemesDirectoryError: If themes directory operations fail
        ThemeGenerationError: If theme generation fails
        Exception: For other unexpected errors during the process
    """
    logger.info(f"Starting CSS theme generation for: {original_css_file_path}")
    logger.info(f"Using themes directory: {themes_directory_path}")
    
    # Convert to Path object for easier manipulation
    css_file = Path(original_css_file_path)
    
    # Check if original CSS file exists
    if not css_file.exists():
        logger.error(f"Original CSS file does not exist: {original_css_file_path}")
        raise CssFileReadError(original_css_file_path, "File not found")
    
    if not css_file.is_file():
        logger.error(f"Original CSS path is not a file: {original_css_file_path}")
        raise CssFileReadError(original_css_file_path, "Path is not a file")
    
    try:
        # Read original CSS file content
        logger.info("Reading original CSS file content")
        with open(css_file, 'r', encoding='utf-8') as file:
            original_css_content = file.read()
        
        logger.info(f"Successfully read original CSS file: {len(original_css_content)} characters")
        
        # Scan existing themes in the directory
        existing_themes = _scan_existing_themes(themes_directory_path)
        
        # Generate new theme variations using OpenAI
        generated_themes = _generate_new_themes(original_css_content, existing_themes)
        
        # Write the generated theme files
        _write_theme_files(themes_directory_path, generated_themes)
        
        logger.info("CSS theme generation completed successfully")
        logger.info(f"Generated {len(generated_themes)} new theme variations")
        
    except (CssFileReadError, ThemesDirectoryError, ThemeGenerationError):
        # Re-raise our custom exceptions
        raise
    except Exception as e:
        logger.error(f"Unexpected error during CSS theme generation: {e}")
        raise Exception(f"CSS theme generation failed: {e}")


def _parse_arguments() -> argparse.Namespace:
    """
    Parse command line arguments for CSS theme generator.
    
    Returns:
        Parsed arguments namespace containing themes_directory and original_css_file
        
    Raises:
        SystemExit: If argument parsing fails or help is requested
    """
    parser = argparse.ArgumentParser(
        description="Generate multiple color theme variations based on an original CSS file",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  python -m workflow.service.css_generator_agent --themes-dir /path/to/themes --original-css /path/to/original.css
  python -m workflow.service.css_generator_agent -t ./themes -o ./styles/main.css
        """
    )
    
    parser.add_argument(
        "--themes-dir", "-t",
        type=str,
        help=f"Path to the themes directory where JSON and CSS files are stored"
    )
    
    parser.add_argument(
        "--original-css", "-o",
        type=str,
        help=f"Path to the original CSS file to base variations on"
    )
    
    return parser.parse_args()


def _validate_arguments(args: argparse.Namespace) -> None:
    """
    Validate command line arguments.
    
    Args:
        args: Parsed command line arguments
        
    Raises:
        SystemExit: If validation fails
    """
    # Validate themes directory path
    if not args.themes_dir:
        logger.error("Themes directory path cannot be empty")
        sys.exit(1)
    
    # Validate original CSS file path
    if not args.original_css:
        logger.error("Original CSS file path cannot be empty")
        sys.exit(1)
    
    # Check if original CSS file exists
    css_file = Path(args.original_css)
    if not css_file.exists():
        logger.error(f"Original CSS file does not exist: {args.original_css}")
        sys.exit(1)
    
    if not css_file.is_file():
        logger.error(f"Original CSS path is not a file: {args.original_css}")
        sys.exit(1)
    
    logger.info(f"Arguments validated successfully")
    logger.info(f"Themes directory: {args.themes_dir}")
    logger.info(f"Original CSS file: {args.original_css}")


def main() -> None:
    """
    Standalone entry point to generate additional CSS color themes.

    This function parses command line arguments to get the themes directory
    and original CSS file paths, then invokes css_generator_agent to
    generate five new and unique color theme variations.

    Command line arguments:
        --themes-dir, -t: Path to the themes directory (optional, has default)
        --original-css, -o: Path to the original CSS file (optional, has default)

    Raises:
        CssFileReadError: If the original CSS file cannot be read
        ThemesDirectoryError: If themes directory operations fail
        ThemeGenerationError: If theme generation fails
        SystemExit: If argument parsing or validation fails
        Exception: For other unexpected errors during the process
    """
    logger.info("Standalone CSS theme generator started")

    try:
        # Parse and validate command line arguments
        args = _parse_arguments()
        _validate_arguments(args)
        
        # Run CSS theme generation with parsed arguments
        css_generator_agent(
            themes_directory_path=args.themes_dir,
            original_css_file_path=args.original_css
        )
        logger.info("Standalone CSS theme generator finished successfully")
        
    except (CssFileReadError, ThemesDirectoryError, ThemeGenerationError) as e:
        logger.error(f"CSS theme generation failed: {e}")
        sys.exit(1)
    except SystemExit:
        # Re-raise SystemExit (from argparse or validation)
        raise
    except Exception as e:
        logger.error(f"Unexpected error: {e}")
        sys.exit(1)


if __name__ == "__main__":
    main()
